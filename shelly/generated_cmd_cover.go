// code generated by go generate - look at command.go.tmpl for source file
package shelly

/*
 > Command Cover.GetConfig
 >
*/

// CoverGetConfigRequest is the request of GetConfig.
type CoverGetConfigRequest struct {
	// Id of the Cover component instance.
	Id float64 `json:"id"`
}

// CoverGetConfigResponse is the response of GetConfig.
type CoverGetConfigResponse struct {
	// Amperes, limit that must be exceeded to trigger an overcurrent error.
	CurrentLimit float64 `json:"current_limit"`
	// Id of the Cover component instance.
	Id float64 `json:"id"`
	// Optional. One of single, dual or detached, only present if there is at least one input associated with the Cover instance. Single - Cover operation in both open and close directions is controlled via a single input. In this mode, only input_0 is used to open/close/stop the Cover. It doesn&#39;t matter if input_0 has in_type=switch or in_type=button, the behavior is the same: each switch toggle or button press cycles between open/stop/close/stop/... In single mode, input_1 is free to be used as a safety switch (e.g. end-of-motion limit switch, emergency-stop, etc.). dual - Cover operation is controlled via two inputs, one for open and one for close. In this mode, input_0 is used to open the Cover, input_1 is used to close the Cover.The exact behavior depends on the in_type of the inputs: if in_type = switch: toggle the switch to ON to move in the associated direction; toggle the switch to OFF to stop, if in_type = button: press the button to move in the associated direction; press the button again to stop. detached - Cover operation via the input/inputs is prohibited.
	InMode string `json:"in_mode"`
	// Defines Cover target state on power-on, one of open (Cover will fully open), closed (Cover will fully close) or stopped (Cover will not change its position).
	InitialState string `json:"initial_state"`
	// Defines the motor rotation for open and close directions (changing this parameter requires a reboot). false - On open motor rotates clockwise, on close motor rotates counter-clockwise. true - On open motor rotates counter-clockwise, on close motor rotates clockwise.
	InvertDirections bool `json:"invert_directions"`
	// Default timeout after which Cover will stop moving in close direction.
	MaxtimeClose float64 `json:"maxtime_close"`
	// Default timeout after which Cover will stop moving in open direction.
	MaxtimeOpen float64 `json:"maxtime_open"`
	// configuration of the Cover motor. The exact contents depend on the type of motor used. The descriptions below are valid when an AC motor is used.
	Motor CoverGetConfigResponseMotor `json:"motor"`
	// Optional. Name of the cover instance.
	Name string `json:"name"`
	// Defines the behavior of the obstruction detection safety feature.
	ObstructionDetection CoverGetConfigResponseObstructionDetection `json:"obstruction_detection"`
	// Watts, limit that must be exceeded to trigger an overpower error.
	PowerLimit float64 `json:"power_limit"`
	// Defines the behavior of the safety switch feature, only present if there are two inputs associated with the Cover instance. The safety_switch feature will only work when in_mode=single
	SafetySwitch CoverGetConfigResponseSafetySwitch `json:"safety_switch"`
	// Only present if there are two inputs associated with the Cover instance, defines whether the functions of the two inputs are swapped. The effect of swap_inputs is observable only when in_mode != detached. When swap_inputs is false: If in_mode = dual: input_0 is used to open, input_1 is used to close. If in_mode = single: input_0 is used to open/close/stop, input_1 is used as safety switch or is not used at all. When swap_inputs is true: If in_mode = dual: input_0 is used to close, input_1 is used to open. If in_mode = single: input_0 is used as safety switch or is not used at all, input_1 is used to open/close/stop.
	SwapInputs bool `json:"swap_inputs"`
	// Volts, limit that must be exceeded to trigger an undervoltage error.
	UndervoltageLimit float64 `json:"undervoltage_limit"`
	// Volts, limit that must be exceeded to trigger an undervoltage error.
	VoltageLimit float64 `json:"voltage_limit"`
}

// CoverGetConfigResponseMotor is the response of CoverGetConfigResponseMotor.
type CoverGetConfigResponseMotor struct {
	// Seconds, minimum period of time in idle state before state is confirmed.
	IdleConfirmPeriod float64 `json:"idle_confirm_period"`
	// Watts, threshold below which the motor is considered stopped.
	IdlePowerThr float64 `json:"idle_power_thr"`
}

// CoverGetConfigResponseObstructionDetection is the response of CoverGetConfigResponseObstructionDetection.
type CoverGetConfigResponseObstructionDetection struct {
	// Optional. The recovery action which should be performed if the safety switch is engaged while moving in a monitored direction, one of: stop - Immediately stop Cover. reverse - Immediately stop Cover, then move in the opposite direction until a fully open or fully closed position is reached.
	Action string `json:"action"`
	// The direction of motion for which safety switch should be monitored, one of open, close, both
	Direction string `json:"direction"`
	// true when obstruction detection is enabled, false otherwise
	Enable bool `json:"enable"`
	// Seconds, time to wait after Cover starts moving before obstruction detection is activated (to avoid false detections because of the initial power consumption spike).
	Holdoff float64 `json:"holdoff"`
	// Watts, power consumption above this threshold should be interpreted as objects obstructing Cover movement. This property is editable at any time, but note that during the cover calibration procedure (Cover.Calibrate), power_thr will be automatically set to the peak power consumption &#43; 15%, overwriting the current value. The automatic setup of power_thr during calibration will only start tracking power values when the holdoff time (see below) has elapsed.
	PowerThr float64 `json:"power_thr"`
}

// CoverGetConfigResponseSafetySwitch is the response of CoverGetConfigResponseSafetySwitch.
type CoverGetConfigResponseSafetySwitch struct {
	// Optional. The recovery action which should be performed if the safety switch is engaged while moving in a monitored direction, one of: stop - Immediately stop Cover. reverse - Immediately stop Cover, then move in the opposite direction until a fully open or fully closed position is reached. pause - Immediately stop Cover, then either: wait for a command to move in an allowed direction (see below) or automatically continue movement in the same direction (i.e. the one that was interrupted) when the safety switch is disengaged
	Action string `json:"action"`
	// Optional. Allowed movement direction when the safety switch is engaged while moving in a monitored direction: null - null means Cover can&#39;t be moved in neither open nor close directions while the safety switch is engaged. reverse - the only other option is reverse, which means Cover can only be moved in the direction opposite to the one that was interrupted (for example, if the safety switch was hit while opening, Cover can only be commanded to close if the switch is not disengaged)
	AllowedMove string `json:"allowed_move"`
	// The direction of motion for which safety switch should be monitored, one of open, close, both
	Direction string `json:"direction"`
	// true when safety switch is enabled, false otherwise
	Enable bool `json:"enable"`
}

// readResponse reads the response into the given interface.
func (r *CoverGetConfigResponse) readResponse(reader *responseReader) error {
	if reader.Response == nil {
		return ErrInvalidResponse
	}
	return reader.Read(r)
}

// GetConfig
func (c CoverClient) GetConfig(args CoverGetConfigRequest) (resp *CoverGetConfigResponse, err error) {
	reader := NewResponseReader()

	if err = c.call("Cover.GetConfig", args, &reader.Response); err != nil {
		return
	}

	resp = &CoverGetConfigResponse{}
	return resp, resp.readResponse(reader)
}

// Getcurrent_limit returns the current_limit value.
func (r *CoverGetConfigResponse) GetCurrentLimit() float64 {
	return r.CurrentLimit
}

// Getid returns the id value.
func (r *CoverGetConfigResponse) GetId() float64 {
	return r.Id
}

// Getin_mode returns the in_mode value.
func (r *CoverGetConfigResponse) GetInMode() string {
	return r.InMode
}

// Getinitial_state returns the initial_state value.
func (r *CoverGetConfigResponse) GetInitialState() string {
	return r.InitialState
}

// Getinvert_directions returns the invert_directions value.
func (r *CoverGetConfigResponse) GetInvertDirections() bool {
	return r.InvertDirections
}

// Getmaxtime_close returns the maxtime_close value.
func (r *CoverGetConfigResponse) GetMaxtimeClose() float64 {
	return r.MaxtimeClose
}

// Getmaxtime_open returns the maxtime_open value.
func (r *CoverGetConfigResponse) GetMaxtimeOpen() float64 {
	return r.MaxtimeOpen
}

// Getmotor returns the motor value.
func (r *CoverGetConfigResponse) GetMotor() CoverGetConfigResponseMotor {
	return r.Motor
}

// Getname returns the name value.
func (r *CoverGetConfigResponse) GetName() string {
	return r.Name
}

// Getobstruction_detection returns the obstruction_detection value.
func (r *CoverGetConfigResponse) GetObstructionDetection() CoverGetConfigResponseObstructionDetection {
	return r.ObstructionDetection
}

// Getpower_limit returns the power_limit value.
func (r *CoverGetConfigResponse) GetPowerLimit() float64 {
	return r.PowerLimit
}

// Getsafety_switch returns the safety_switch value.
func (r *CoverGetConfigResponse) GetSafetySwitch() CoverGetConfigResponseSafetySwitch {
	return r.SafetySwitch
}

// Getswap_inputs returns the swap_inputs value.
func (r *CoverGetConfigResponse) GetSwapInputs() bool {
	return r.SwapInputs
}

// Getundervoltage_limit returns the undervoltage_limit value.
func (r *CoverGetConfigResponse) GetUndervoltageLimit() float64 {
	return r.UndervoltageLimit
}

// Getvoltage_limit returns the voltage_limit value.
func (r *CoverGetConfigResponse) GetVoltageLimit() float64 {
	return r.VoltageLimit
}

// GetIdleConfirmPeriod returns the idle_confirm_period value.
func (r *CoverGetConfigResponseMotor) GetIdleConfirmPeriod() float64 {
	return r.IdleConfirmPeriod
}

// GetIdlePowerThr returns the idle_power_thr value.
func (r *CoverGetConfigResponseMotor) GetIdlePowerThr() float64 {
	return r.IdlePowerThr
}

// GetAction returns the action value.
func (r *CoverGetConfigResponseObstructionDetection) GetAction() string {
	return r.Action
}

// GetDirection returns the direction value.
func (r *CoverGetConfigResponseObstructionDetection) GetDirection() string {
	return r.Direction
}

// GetEnable returns the enable value.
func (r *CoverGetConfigResponseObstructionDetection) GetEnable() bool {
	return r.Enable
}

// GetHoldoff returns the holdoff value.
func (r *CoverGetConfigResponseObstructionDetection) GetHoldoff() float64 {
	return r.Holdoff
}

// GetPowerThr returns the power_thr value.
func (r *CoverGetConfigResponseObstructionDetection) GetPowerThr() float64 {
	return r.PowerThr
}

// GetAction returns the action value.
func (r *CoverGetConfigResponseSafetySwitch) GetAction() string {
	return r.Action
}

// GetAllowedMove returns the allowed_move value.
func (r *CoverGetConfigResponseSafetySwitch) GetAllowedMove() string {
	return r.AllowedMove
}

// GetDirection returns the direction value.
func (r *CoverGetConfigResponseSafetySwitch) GetDirection() string {
	return r.Direction
}

// GetEnable returns the enable value.
func (r *CoverGetConfigResponseSafetySwitch) GetEnable() bool {
	return r.Enable
}

/*
 > Command Cover.SetConfig
 >
*/

// CoverSetConfigRequest is the request of SetConfig.
type CoverSetConfigRequest struct {
	// The configuration to apply to the Cover instance.
	Config CoverSetConfigRequestConfig `json:"config"`
	// The ID of the Cover instance to configure.
	Id float64 `json:"id"`
}

// Extra CoverSetConfigRequestConfig is the request of CoverSetConfigRequestConfig.
type CoverSetConfigRequestConfig struct {
	// Amperes, limit that must be exceeded to trigger an overcurrent error.
	CurrentLimit float64 `json:"current_limit"`
	// Id of the Cover component instance.
	Id float64 `json:"id"`
	// Optional. One of single, dual or detached, only present if there is at least one input associated with the Cover instance. Single - Cover operation in both open and close directions is controlled via a single input. In this mode, only input_0 is used to open/close/stop the Cover. It doesn&#39;t matter if input_0 has in_type=switch or in_type=button, the behavior is the same: each switch toggle or button press cycles between open/stop/close/stop/... In single mode, input_1 is free to be used as a safety switch (e.g. end-of-motion limit switch, emergency-stop, etc.). dual - Cover operation is controlled via two inputs, one for open and one for close. In this mode, input_0 is used to open the Cover, input_1 is used to close the Cover.The exact behavior depends on the in_type of the inputs: if in_type = switch: toggle the switch to ON to move in the associated direction; toggle the switch to OFF to stop, if in_type = button: press the button to move in the associated direction; press the button again to stop. detached - Cover operation via the input/inputs is prohibited.
	InMode string `json:"in_mode"`
	// Defines Cover target state on power-on, one of open (Cover will fully open), closed (Cover will fully close) or stopped (Cover will not change its position).
	InitialState string `json:"initial_state"`
	// Defines the motor rotation for open and close directions (changing this parameter requires a reboot). false - On open motor rotates clockwise, on close motor rotates counter-clockwise. true - On open motor rotates counter-clockwise, on close motor rotates clockwise.
	InvertDirections bool `json:"invert_directions"`
	// Default timeout after which Cover will stop moving in close direction.
	MaxtimeClose float64 `json:"maxtime_close"`
	// Default timeout after which Cover will stop moving in open direction.
	MaxtimeOpen float64 `json:"maxtime_open"`
	// configuration of the Cover motor. The exact contents depend on the type of motor used. The descriptions below are valid when an AC motor is used.
	Motor CoverSetConfigRequestConfigMotor `json:"motor"`
	// Optional. Name of the cover instance.
	Name string `json:"name"`
	// Defines the behavior of the obstruction detection safety feature.
	ObstructionDetection CoverSetConfigRequestConfigObstructionDetection `json:"obstruction_detection"`
	// Watts, limit that must be exceeded to trigger an overpower error.
	PowerLimit float64 `json:"power_limit"`
	// Defines the behavior of the safety switch feature, only present if there are two inputs associated with the Cover instance. The safety_switch feature will only work when in_mode=single
	SafetySwitch CoverSetConfigRequestConfigSafetySwitch `json:"safety_switch"`
	// Only present if there are two inputs associated with the Cover instance, defines whether the functions of the two inputs are swapped. The effect of swap_inputs is observable only when in_mode != detached. When swap_inputs is false: If in_mode = dual: input_0 is used to open, input_1 is used to close. If in_mode = single: input_0 is used to open/close/stop, input_1 is used as safety switch or is not used at all. When swap_inputs is true: If in_mode = dual: input_0 is used to close, input_1 is used to open. If in_mode = single: input_0 is used as safety switch or is not used at all, input_1 is used to open/close/stop.
	SwapInputs bool `json:"swap_inputs"`
	// Volts, limit that must be exceeded to trigger an undervoltage error.
	UndervoltageLimit float64 `json:"undervoltage_limit"`
	// Volts, limit that must be exceeded to trigger an undervoltage error.
	VoltageLimit float64 `json:"voltage_limit"`
}

// Extra CoverSetConfigRequestConfigMotor is the request of CoverSetConfigRequestConfigMotor.
type CoverSetConfigRequestConfigMotor struct {
	// Seconds, minimum period of time in idle state before state is confirmed.
	IdleConfirmPeriod float64 `json:"idle_confirm_period"`
	// Watts, threshold below which the motor is considered stopped.
	IdlePowerThr float64 `json:"idle_power_thr"`
}

// Extra CoverSetConfigRequestConfigObstructionDetection is the request of CoverSetConfigRequestConfigObstructionDetection.
type CoverSetConfigRequestConfigObstructionDetection struct {
	// Optional. The recovery action which should be performed if the safety switch is engaged while moving in a monitored direction, one of: stop - Immediately stop Cover. reverse - Immediately stop Cover, then move in the opposite direction until a fully open or fully closed position is reached.
	Action string `json:"action"`
	// The direction of motion for which safety switch should be monitored, one of open, close, both
	Direction string `json:"direction"`
	// true when obstruction detection is enabled, false otherwise
	Enable bool `json:"enable"`
	// Seconds, time to wait after Cover starts moving before obstruction detection is activated (to avoid false detections because of the initial power consumption spike).
	Holdoff float64 `json:"holdoff"`
	// Watts, power consumption above this threshold should be interpreted as objects obstructing Cover movement. This property is editable at any time, but note that during the cover calibration procedure (Cover.Calibrate), power_thr will be automatically set to the peak power consumption &#43; 15%, overwriting the current value. The automatic setup of power_thr during calibration will only start tracking power values when the holdoff time (see below) has elapsed.
	PowerThr float64 `json:"power_thr"`
}

// Extra CoverSetConfigRequestConfigSafetySwitch is the request of CoverSetConfigRequestConfigSafetySwitch.
type CoverSetConfigRequestConfigSafetySwitch struct {
	// Optional. The recovery action which should be performed if the safety switch is engaged while moving in a monitored direction, one of: stop - Immediately stop Cover. reverse - Immediately stop Cover, then move in the opposite direction until a fully open or fully closed position is reached. pause - Immediately stop Cover, then either: wait for a command to move in an allowed direction (see below) or automatically continue movement in the same direction (i.e. the one that was interrupted) when the safety switch is disengaged
	Action string `json:"action"`
	// Optional. Allowed movement direction when the safety switch is engaged while moving in a monitored direction: null - null means Cover can&#39;t be moved in neither open nor close directions while the safety switch is engaged. reverse - the only other option is reverse, which means Cover can only be moved in the direction opposite to the one that was interrupted (for example, if the safety switch was hit while opening, Cover can only be commanded to close if the switch is not disengaged)
	AllowedMove string `json:"allowed_move"`
	// The direction of motion for which safety switch should be monitored, one of open, close, both
	Direction string `json:"direction"`
	// true when safety switch is enabled, false otherwise
	Enable bool `json:"enable"`
}

// CoverSetConfigResponse is the response of SetConfig.
type CoverSetConfigResponse struct {
}

// readResponse reads the response into the given interface.
func (r *CoverSetConfigResponse) readResponse(reader *responseReader) error {
	if reader.Response == nil {
		return ErrInvalidResponse
	}
	return reader.Read(r)
}

// SetConfig
func (c CoverClient) SetConfig(args CoverSetConfigRequest) (resp *CoverSetConfigResponse, err error) {
	reader := NewResponseReader()

	if err = c.call("Cover.SetConfig", args, &reader.Response); err != nil {
		return
	}

	resp = &CoverSetConfigResponse{}
	return resp, resp.readResponse(reader)
}

/*
 > Command Cover.GetStatus
 > Get Cover status
*/

// CoverGetStatusRequest is the request of GetStatus.
type CoverGetStatusRequest struct {
	// The numeric ID of the Cover component instance
	Id float64 `json:"id"`
}

// CoverGetStatusResponse is the response of GetStatus.
type CoverGetStatusResponse struct {
	// Optional. Information about the active energy counter (shown if applicable)
	Aenergy CoverGetStatusResponseAenergy `json:"aenergy,omitempty"`
	// Active power in Watts
	Apower float64 `json:"apower"`
	// Current in Amperes
	Current float64 `json:"current"`
	// Only present if Cover is calibrated. Represents current position in percent from 0 (fully closed) to 100 (fully open); null if position is unknown
	CurrentPos float64 `json:"current_pos"`
	// Only present if an error condition has occurred
	Errors []string `json:"errors"`
	// The numeric ID of the Cover component instance
	Id float64 `json:"id"`
	// Only present if Cover is actively moving in either open or close directions. Represents the time at which the movement has begun
	MoveStartedAt float64 `json:"move_started_at"`
	// Seconds, only present if Cover is actively moving in either open or close directions. Cover will automatically stop after the timeout expires
	MoveTimeout float64 `json:"move_timeout"`
	// Power factor
	Pf float64 `json:"pf"`
	// False if Cover is not calibrated and only discrete open/close is possible; true if Cover is calibrated and can be commanded to go to arbitrary positions between fully open and fully closed
	PosControl bool `json:"pos_control"`
	// Source of the last command
	Source string `json:"source"`
	// One of open (Cover is fully open), closed (Cover is fully closed), opening (Cover is actively opening), closing (Cover is actively closing), stopped (Cover is not moving, and is neither fully open nor fully closed, or the open/close state is unknown), calibrating (Cover is performing a calibration procedure)
	State string `json:"state"`
	// Only present if Cover is calibrated and is actively moving to a requested position in either open or close directions. Represents the target position in percent from 0 (fully closed) to 100 (fully open); null if target position has been reached or the movement was cancelled
	TargetPos float64 `json:"target_pos"`
	// Temperature sensor information, only present if a temperature monitor is associated with the Cover instance
	Temperature CoverGetStatusResponseTemperature `json:"temperature"`
	// Voltage in Volts
	Voltage float64 `json:"voltage"`
}

// CoverGetStatusResponseAenergy is the response of CoverGetStatusResponseAenergy.
type CoverGetStatusResponseAenergy struct {
	// Energy consumption by minute (in Milliwatt-hours) for the last three minutes (the lower the index of the element in the array, the closer to the current moment the minute)
	ByMinute []int `json:"by_minute"`
	// Unix timestamp of the first second of the last minute (in UTC)
	MinuteTs float64 `json:"minute_ts"`
	// Total energy consumed in Watt-hours
	Total float64 `json:"total"`
}

// CoverGetStatusResponseTemperature is the response of CoverGetStatusResponseTemperature.
type CoverGetStatusResponseTemperature struct {
	// Temperature in Celsius (null if temperature is out of the measurement range)
	TC float64 `json:"tc"`
	// Temperature in Fahrenheit (null if temperature is out of the measurement range)
	TF float64 `json:"tf"`
}

// readResponse reads the response into the given interface.
func (r *CoverGetStatusResponse) readResponse(reader *responseReader) error {
	if reader.Response == nil {
		return ErrInvalidResponse
	}
	return reader.Read(r)
}

// GetStatus Get Cover status
func (c CoverClient) GetStatus(args CoverGetStatusRequest) (resp *CoverGetStatusResponse, err error) {
	reader := NewResponseReader()

	if err = c.call("Cover.GetStatus", args, &reader.Response); err != nil {
		return
	}

	resp = &CoverGetStatusResponse{}
	return resp, resp.readResponse(reader)
}

// Getaenergy returns the aenergy value.
func (r *CoverGetStatusResponse) GetAenergy() CoverGetStatusResponseAenergy {
	return r.Aenergy
}

// Getapower returns the apower value.
func (r *CoverGetStatusResponse) GetApower() float64 {
	return r.Apower
}

// Getcurrent returns the current value.
func (r *CoverGetStatusResponse) GetCurrent() float64 {
	return r.Current
}

// Getcurrent_pos returns the current_pos value.
func (r *CoverGetStatusResponse) GetCurrentPos() float64 {
	return r.CurrentPos
}

// Geterrors returns the errors value.
func (r *CoverGetStatusResponse) GetErrors() []string {
	return r.Errors
}

// Getid returns the id value.
func (r *CoverGetStatusResponse) GetId() float64 {
	return r.Id
}

// Getmove_started_at returns the move_started_at value.
func (r *CoverGetStatusResponse) GetMoveStartedAt() float64 {
	return r.MoveStartedAt
}

// Getmove_timeout returns the move_timeout value.
func (r *CoverGetStatusResponse) GetMoveTimeout() float64 {
	return r.MoveTimeout
}

// Getpf returns the pf value.
func (r *CoverGetStatusResponse) GetPf() float64 {
	return r.Pf
}

// Getpos_control returns the pos_control value.
func (r *CoverGetStatusResponse) GetPosControl() bool {
	return r.PosControl
}

// Getsource returns the source value.
func (r *CoverGetStatusResponse) GetSource() string {
	return r.Source
}

// Getstate returns the state value.
func (r *CoverGetStatusResponse) GetState() string {
	return r.State
}

// Gettarget_pos returns the target_pos value.
func (r *CoverGetStatusResponse) GetTargetPos() float64 {
	return r.TargetPos
}

// Gettemperature returns the temperature value.
func (r *CoverGetStatusResponse) GetTemperature() CoverGetStatusResponseTemperature {
	return r.Temperature
}

// Getvoltage returns the voltage value.
func (r *CoverGetStatusResponse) GetVoltage() float64 {
	return r.Voltage
}

// GetByMinute returns the by_minute value.
func (r *CoverGetStatusResponseAenergy) GetByMinute() []int {
	return r.ByMinute
}

// GetMinuteTs returns the minute_ts value.
func (r *CoverGetStatusResponseAenergy) GetMinuteTs() float64 {
	return r.MinuteTs
}

// GetTotal returns the total value.
func (r *CoverGetStatusResponseAenergy) GetTotal() float64 {
	return r.Total
}

// GetTC returns the tC value.
func (r *CoverGetStatusResponseTemperature) GetTC() float64 {
	return r.TC
}

// GetTF returns the tF value.
func (r *CoverGetStatusResponseTemperature) GetTF() float64 {
	return r.TF
}

/*
 > Command Cover.Open
 > Open Cover
*/

// CoverOpenRequest is the request of Open.
type CoverOpenRequest struct {
	// Optional. If duration is not provided, Cover will fully open, unless it times out because of maxtime_open first. If duration (seconds) is provided, Cover will move in open direction for the specified time. duration must be in range [0.1..maxtime_open]
	Duration float64 `json:"duration"`
	// The numeric ID of the Cover component instance
	Id float64 `json:"id"`
}

// CoverOpenResponse is the response of Open.
type CoverOpenResponse struct {
}

// readResponse reads the response into the given interface.
func (r *CoverOpenResponse) readResponse(reader *responseReader) error {
	if reader.Response == nil {
		return ErrInvalidResponse
	}
	return reader.Read(r)
}

// Open Open Cover
func (c CoverClient) Open(args CoverOpenRequest) (resp *CoverOpenResponse, err error) {
	reader := NewResponseReader()

	if err = c.call("Cover.Open", args, &reader.Response); err != nil {
		return
	}

	resp = &CoverOpenResponse{}
	return resp, resp.readResponse(reader)
}

/*
 > Command Cover.Close
 > Close Cover
*/

// CoverCloseRequest is the request of Close.
type CoverCloseRequest struct {
	// The numeric ID of the Cover component instance
	Id float64 `json:"id"`
}

// CoverCloseResponse is the response of Close.
type CoverCloseResponse struct {
}

// readResponse reads the response into the given interface.
func (r *CoverCloseResponse) readResponse(reader *responseReader) error {
	if reader.Response == nil {
		return ErrInvalidResponse
	}
	return reader.Read(r)
}

// Close Close Cover
func (c CoverClient) Close(args CoverCloseRequest) (resp *CoverCloseResponse, err error) {
	reader := NewResponseReader()

	if err = c.call("Cover.Close", args, &reader.Response); err != nil {
		return
	}

	resp = &CoverCloseResponse{}
	return resp, resp.readResponse(reader)
}

/*
 > Command Cover.GoToPosition
 > Go to position
*/

// CoverGoToPositionRequest is the request of GoToPosition.
type CoverGoToPositionRequest struct {
	// The numeric ID of the Cover component instance
	Id float64 `json:"id"`
	// Required and mutually exclusive (at least one of them pos/rel be provided, but not both at the same time). pos represents target position in %, allowed range [0..100]. If rel is provided, Cover will move to a target_position = current_position &#43; rel. If the value of rel is so big that it results in overshoot (i.e. target_position is beyond fully open / fully closed), target_position will be silently capped to fully open / fully closed
	Pos float64 `json:"pos"`
	// Required and mutually exclusive (at least one of them pos/rel be provided, but not both at the same time). rel represents relative move in %, allowed range [-100..100]
	Rel float64 `json:"rel"`
}

// CoverGoToPositionResponse is the response of GoToPosition.
type CoverGoToPositionResponse struct {
}

// readResponse reads the response into the given interface.
func (r *CoverGoToPositionResponse) readResponse(reader *responseReader) error {
	if reader.Response == nil {
		return ErrInvalidResponse
	}
	return reader.Read(r)
}

// GoToPosition Go to position
func (c CoverClient) GoToPosition(args CoverGoToPositionRequest) (resp *CoverGoToPositionResponse, err error) {
	reader := NewResponseReader()

	if err = c.call("Cover.GoToPosition", args, &reader.Response); err != nil {
		return
	}

	resp = &CoverGoToPositionResponse{}
	return resp, resp.readResponse(reader)
}
